"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Validate_1 = __importDefault(require("../Validate"));
const util_1 = require("../util");
/**
 * Returns a formatted string representing the difference between two timestamps.
 * @param options - An optional object containing the timestamps and format options.
 * @returns The formatted string representing the difference between the two timestamps.
 */
const getCompareDate = (...options) => {
    // Parse and validate the options
    const parseOptions = Validate_1.default.optionsCompareData(options);
    const { timestamp1, timestamp2 } = Validate_1.default.timestamps(parseOptions?.timestamp1, parseOptions?.timestamp2);
    const format = Validate_1.default.dateFormat(parseOptions?.format);
    // Calculate the elapsed time in milliseconds
    const elapsed = Math.abs(timestamp2 - timestamp1);
    // Initialize the result string and the remaining value
    let diff = "";
    let value = elapsed;
    // Iterate over each date type in the dateList
    for (const dateType in util_1.dateList) {
        const { unit, aliases } = util_1.dateList[dateType];
        // Check if the remaining value is greater than or equal to the current unit
        if (value >= unit) {
            // Calculate the number of units and get the alias for the current date type
            const valueParsed = Math.floor(value / unit);
            const name = aliases.at(-1);
            // Append the formatted string to the result based on the current date type
            switch (name) {
                case "y":
                    diff += (0, util_1.compareDataParse)(valueParsed, format, util_1.dateList.year);
                    break;
                case "mh":
                    diff += (0, util_1.compareDataParse)(valueParsed, format, util_1.dateList.month);
                    break;
                case "w":
                    diff += (0, util_1.compareDataParse)(valueParsed, format, util_1.dateList.week);
                    break;
                case "d":
                    diff += (0, util_1.compareDataParse)(valueParsed, format, util_1.dateList.day);
                    break;
                case "h":
                    diff += (0, util_1.compareDataParse)(valueParsed, format, util_1.dateList.hour);
                    break;
                case "m":
                    diff += (0, util_1.compareDataParse)(valueParsed, format, util_1.dateList.minute);
                    break;
                case "s":
                    diff += (0, util_1.compareDataParse)(valueParsed, format, util_1.dateList.second);
                    break;
                default: {
                    if (elapsed < 1000)
                        diff += (0, util_1.compareDataParse)(valueParsed, format, util_1.dateList.millisecond);
                    break;
                }
            }
            // Add a separator if the remaining value is greater than or equal to 60000 (1 minute)
            if (value >= 60000)
                diff += format === "long" ? ", " : " ";
            // Update the remaining value
            value -= Math.floor(elapsed / unit) * unit;
        }
    }
    // If no date type matched, append the formatted string for milliseconds
    if (!diff?.length)
        diff += (0, util_1.compareDataParse)(elapsed, format, util_1.dateList.millisecond);
    // Return the final result string
    return diff;
};
exports.default = getCompareDate;
